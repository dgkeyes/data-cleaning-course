---
title: "Data cleaning with R"
subtitle: "<br/>Regular expressions and their role in data cleaning"
author: "Luis D. Verde Arregoitia"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
```{r xaringan-tachyons, echo=FALSE}
xaringanExtra::use_tachyons()
```

```{r xaringan-panelset, echo=FALSE}
xaringanExtra::use_panelset()
```

```{r preloaded data, echo=FALSE}
library(palmerpenguins)
#data(package = 'palmerpenguins')
```

```{r load libraries, echo=FALSE, include=FALSE}
library(regexplain)
library(dplyr)
library(stringr)
library(ggplot2)
data(msleep)
options(tibble.print_max = 5, tibble.print_min = 5)
```

class: center, middle

# What are regular expressions?

???

---
class: middle

.f1[Specially encoded .avenir[strings] of characters that match patterns in other text strings.] 

---

# .fancy[Strings]

.f3[A collection of characters that make up one element of a vector:]
```{r}
test_string <- "This sentence is a string."
```

.f3[We can store multiple strings in a character vector:]

```{r}
pets <-  c("dog","cat","parrot")
```
.pull-left[.f3[
Column names and values in a data frame can also be strings:]]
```{r include=FALSE}
library(gt)
library(tibble)
library(magrittr)
drinks_df <- tibble(drink=c("Coffee","Tea","Juice"),price=c(3.50,2.99,3.20))
```

.pull-right[
```{r echo=FALSE}
drinks_df %>%
  gt() %>%
  tab_style(
    style = list(
      cell_fill(color = "yellow")
    ),
    locations = cells_body(
      columns = vars(drink)
    )
  ) %>%
  tab_options(column_labels.background.color = "yellow")

```
]

---
# Strings in R are _case sensitive_

.f3[Uppercase and lowercase letters are treated as distinct]

```{r}
"cat"=="CAT"
```
```{r}
"cat"=="cat"
```
.f3[Regex searches are case sensitive by default, so:    
- Build case-insensitive regular expressions
- Change the matching to be case insensitive
- Coerce the input before matching]
---
class: middle
# Why should we learn regular expressions?
---
.f2[
.center[üï∞]  
Cleaning text can be time-consuming and the first hurdle to address when working with less-than-perfect data. 
</br>  
.center[üíªÔ∏è]    
Regular expressions can often replace dozens of lines of code.] 

???

Not specific to any particular programming language or command-line tool
---
# Getting started
</br>
.f2[To search for a specific sequence of characters, the regex we need is simply that sequence of characters.]

</br>
.fl.w-third[
<div class="f2 mt1 pt0 code">Regex</div>
</br>
</br>
.f2[`dog`]
]

.fl.w-third[
<div class="f2 mt0 pt0 code">Input 
string</div>
</br>
.f2["The dog is fat."]
]

.fl.w-third[
<div class="f2 mt0 pt0 code">Match</div>
</br>
</br>
.f2[The .bg-yellow[dog] is fat.]
</br></br>
]
</br></br>
</br>

---
# Literal characters
</br></br>
.f2[We will get a match whenever the characters .orange[`d`], .orange[`o`], and .orange[`g`] occur consecutively in the input text.]
</br></br>
.f2[`"dog"` tells the regex engine:
find a .orange[d], immediately followed by an .orange[o], immediately followed by a .orange[g] .f4[(together and in that particular order)]] 

---
## Literal characters (continued)
</br>
.f2[.orange[`d`], .orange[`o`], and .orange[`g`] are examples of literal characters.

They stand for exactly what they are: .orange[`d`] in the regex matches a ‚Äú.purple[d]‚Äù in the input text, .orange[`o`]  matches an ‚Äú.purple[o]‚Äù in text, and so on.]

---
# Metacharacters
  
</br>  
.f2[The power and flexibility of regular expressions comes from their ability to describe more complex patterns. 
</br>  
If a text pattern can be described verbally, we can most likely write regular expression to match it.]

---
#Possible patterns:
.f3[
- "dog" but not "dogs"  
- "dogs" but only if string begins with "dogs"  
- digits (0,1,2,3,4,5,6,7,8,9)  
- "modeling" or "modelling"  
- words ending in "at"
- strings that start with digits
- dates
- zip codes
- numbers inside square brackets and also the brackets  
- valid Twitter handles (start with @, no spaces or symbols, <16 characters)
- UPPERCASE words
- positions at which strings switch letter case (e.g. lowerUPPER)]

---
# Metacharacters
</br>
.f3[To do more than match literal strings of text, we call on a small subset of characters that have special functionalities when they appear in a regular expression.] 
  </br></br>
 
.f2[Metacharacters include: .f1.orange[[]\^$.|?*+()], which are reserved for unique matching purposes.]

---
# Using metacharacters
.f3[Depending on what they do, we can place most metacharacters into major ‚Äúfamilies‚Äú]

.f3[.b[Wildcards] stand in for unknown characters]  
&nbsp; .f2[.f1.orange.pre[&nbsp;.&nbsp; ] &nbsp;&nbsp; match any character]

.f3[.b[Character sets/classes] match one or more characters]  
&nbsp;.f2[.f1.orange.pre[&nbsp;[]&nbsp;] &nbsp;&nbsp; match a set of characters]  

.f3[.b[Anchors] specify the relative position of the pattern being matched]   
&nbsp;.f2[.orange.f1.pre[&nbsp;^&nbsp;] &nbsp;&nbsp;     starts with]  
&nbsp;.f2[.f1.orange.pre.f1[&nbsp;$&nbsp;]  &nbsp;&nbsp; ends with]

---
## Using metacharacters (continued)
.f3[.b[Quantifiers] specify how many times a character or character class must appear in the input for a match to be found] 

&nbsp;.f2[.orange.f1[&nbsp;?&nbsp;] &nbsp;&nbsp;Zero or one (of the preceding character)]  	
&nbsp;.f2[.orange.f1[&nbsp;\\\*&nbsp;] &nbsp;&nbsp;Zero or more occurrences] 	
&nbsp;.f2[.orange.f1[&nbsp;+&nbsp;]	 &nbsp;&nbsp;One or more occurrences]   
&nbsp;.f2[.orange.f1[&nbsp;{}] 	&nbsp;&nbsp;Exactly the specified number of occurrences]  	

---
## Using metacharacters (continued)
.f3.b[Negation tokens]   
&nbsp;.f2[.orange.f1[[^]] &nbsp;&nbsp;  matches characters not in the specified character set] 

.f3[.b[Alternation] tokens separate a series of alternatives]  
&nbsp;.f2[.orange.f1.b.pre[&nbsp;|&nbsp;] &nbsp;&nbsp; either or]  

.f3.b[Special sequences and escapes]  
&nbsp;.f2[.b.orange.f1.pre[&nbsp;\\&nbsp;] 	&nbsp;&nbsp; signals a shorthand sequence or gives special characters a literal meaning]	

*To use special characters in a regular expression, escape them with a backslash, but the backslash itself needs to be escaped.

*Metacharacters inside a character set are stripped of their special nature.
---
## Using metacharacters (continued)
.f3[.b[Shorthand character classes] are available to refer to commonly-used character sets]   
.f2[.b.orange[\w] &nbsp;all letters and numbers]   
.f2[.b.orange[\d] &nbsp;digits]  
.f2[.orange.b[\t]  &nbsp;tab]  
.f2[.orange.b[\n]  &nbsp;new line]  
.f2[.orange.b[\s]  &nbsp;space]  
.f2[.orange.b[\b]  &nbsp;word boundary]  
.b[Shorthand + negation]   
.f2[.orange.b[\S]  &nbsp;  not whitespace]  
.f2[.orange.b[\D]  &nbsp;  not digits]   
.f2[.orange.b[\W]  &nbsp;not letters, numbers, or underscores]   

---
# Examples

.f2[

.b.orange[\\\\\\\\(hello\\\\\\\\)] matches .b["(hello)"]  

.b.orange[ing$] matches .b["going"] but not .b["ingest"]  

.b.orange[f..l] matches **"fill"**, **"fool"**, but not **"flail"**  

.b.orange[dog|bird] matches **"dog"** or **"bird"**

.b.orange[[cb]at] matches **"cat"**, and **"bat"**, but not   **"rat"**] 
---
## Examples (continued)
.f2[
.b.orange[modell?ing] matches .b["modeling"] and .b["modelling"]  

.b.orange[ya*y!] matches .b["yy"], .b["yay!"], .b["yaaay!"], .b[‚Äúyaaaaaay!‚Äù], etc.  

.b.orange[no+] matches .b[‚Äúno‚Äù], **‚Äúnoo"**, **‚Äúnooooo‚Äù**, etc, but not **‚Äún‚Äù**  
 
.b.orange[^can.\\\*] matches **"can"**, **"canine"**, **"canoli"**, **"canadian"**] 
---
## Examples (continued)
.f2[
.b.orange[\\bcase] matches .b["case"] and .b["casein"] but not .b["suitcase"]  

.b.orange[\\s{3}] matches three spaces 

.b.orange[[^aoeio]] matches consonants
 
.b.orange[^[a-z]+$] matches a lowercase string]
---
# Rexeg in R

.f2.center[Matching patterns]  

grepl - returns a logical vector (match or no match for each element of x)
.f2[`grepl(pattern, x)`]  
grep - returns a vector indicating which elements of x yielded a match  
.f2[`grep(pattern, x)`]


.f2.center[Replacing matches]

gsub - returns the input string with substitutions  
.f2[`gsub(pattern, replacement, x)`]

---
.f2[Matches?]
```{r}
grepl(pattern = "cat", x= c("catalog", "battlecat", "apple"))
```

.f2[Which elements contain matches?]
```{r}
grep(pattern = "cat", x= c("catalog", "battlecat", "apple"))
```

.f2[Replacing matches] (British to American spelling)
```{r}
gsub(pattern = "ou",
     replacement = "o",
     x= c("colour", "neighbour", "honour"))
```
---
# üì¶ [`stringr`](https://stringr.tidyverse.org/)

.f2[Cohesive set of functions for string manipulation]

.f2[- Function names start with .green.b[`str_`]   

- All functions take a vector of strings as the first argument (pipe-friendly)  

- .b.green[`regex()`] modifier to control matching behavior]
---
.f2[Matches?]
```{r}
str_detect(string = c("catalog", "battlecat", "apple"), pattern = "cat")
```

.f2[Which elements contain matches?]
```{r}
str_which(string = c("catalog", "battlecat", "apple"), pattern = "cat")
```

.f2[Replacing matches] (British to American spelling)
```{r}
str_replace(string = c("colour", "neighbour", "honour"),
            pattern = "ou",
            replacement = "o")
```

---
# Understanding a regexp
  
## Online regex testers
.f2[
- [regex101](https://regex101.com/) by Firas Dib 
- [regexr](https://regexr.com/) by Grant Skinner 
- [regexpal](https://www.regexpal.com/) - part of Dan's Developer Tools] 

## Inside R 
.f2[
- üì¶ [`regexplain`](https://www.garrickadenbuie.com/project/regexplain/) by Garrick Aden‚ÄëBuie
- `str_view()` from üì¶ [`stringr`](https://stringr.tidyverse.org/)]

---
class: my-turn

.f2[1. Write regular expressions for the patterns bellow  
2. Test them in an interactive tool]

* "dogs" but only if string begins with "dogs"  
* strings that start with digits
* UPPERCASE strings
* numbers in brackets
* strings that end in ‚Äúat‚Äù but longer than 3 characters 

.f3[ Match the regular expressions against the following vector  
(clue: there is only one match for each pattern)]
```{r}
test_vector <- c("Those dogs are small.","dogs and cats",
                 "34","(34)","rat","watchdog","placemat",
                 "BABY","2011_April","HELP","mice")
```
---
class: inverse
Your turn

.f2[Write regular expressions to match the following:]  
(make sure they work)


* cute, cuuute, cuuuuuute, and cuuuuuuuuute 
* strings with both letters and digits
* strings ending in a period
* lowercase strings
* exactly four digits
* strings without the letter _**s**_

---
# Regular expressions & data cleaning

</br>
.f1[Select, keep, or discard rows and columns]  
</br>
   
.f1[Substitute or recode values]  
 
</br>
.f1[Extract or remove substrings]  

---
# Cleaning data with regex

.f2[Most data wrangling workflows involve specifying columns (variables).]

.f3.blue.b[To select variables in üì¶ `dplyr` and üì¶ `tidyr`:]

.f2[
- write out their names   
- refer to them by position  
- specify ranges of contiguous variables
- use üì¶ `tidyselect` helper functions]

---
.f1[üì¶ `tidyselect` helpers]

</br></br></br>
.f2[.b[`matches()`] takes regular expressions, and selects variables that match a given pattern]
</br></br></br>

.f3[
starts_with(): Starts with a prefix  
ends_with(): Ends with a suffix  
contains(): Contains a literal string] 

---
##Selecting columns

Refer to variables by name  

```{r eval=FALSE}
library(palmerpenguins)
```
```{r}
names(penguins)
```

```{r}
penguins %>% select(species,bill_length_mm,flipper_length_mm)
```

---
##Selecting columns

Matches in variable names  

```{r}
names(penguins)
```

```{r}
penguins %>% select(species, matches("length"))
```

---
## Match values and filter rows

.f2[Mammals sleep dataset]
```{r, eval=FALSE}
library(ggplot2)
```

```{r}
msleep %>% select(name,genus)
```

---
## Match values and filter rows
.f2[Filter to keep rats only]
```{r}
msleep %>% select(name,genus) %>% 
  filter(str_detect(string = name,pattern = "rat"))
```
</br></br>
.dark-green.f3[üêÄ How can we exclude muskrats?]
---
## Substitute or recode values
.panelset[
.panel[.panel-name[set up example data]

```{r panel-chunk, fig.show='hide'}
companies <- data.frame(
  stringsAsFactors = FALSE,
           Company = c("Olsson","Ollsson","olson",
                       "Olsson LLC","Olsson Group","Olsonn","Mila Inc",
                       "Mila Inc","Mila Inc"),
         Operation = c("Logistics","Logistics",
                       "Logistics","Logistics","Logistics","Logistics",
                       "E-commerce","E-commerce","E-commerce")
)
```
]

.panel[.panel-name[example data]
```{r, fig.show='hide'}
companies
```
]
]
---
### Substitute or recode values
.i[(correct name should be Olsson)]  
```{r}
companies %>% 
  mutate(Company=str_replace(Company,"[o|O]l+s+on+.*","Olsson")) %>% 
  distinct()
```

---
# Case insensitive matching

```{r}
companies %>%
  mutate(Company = str_replace(
    Company,
    regex("ol+s+on+.*", ignore_case = TRUE), "Olsson"
  )) %>%
  distinct()
```

---
#Extract or remove substrings  
.panelset[
.panel[.panel-name[set up example data]
```{r, fig.show='hide'}
team_record <- 
tibble::tribble(
  ~week,               ~result,  ~game,
    12L,                "loss", "home",
    13L, "loss (disqualified)", "away",
    14L,    "win (overturned)", "away",
    15L,       "win (forefit)", "home",
    16L,       "win (rematch)", "away"
  )
```
]
.panel[.panel-name[example data]
```{r, fig.show='hide'}
team_record
```
]
]
.f2[
.b[`str_extract()`] .f3[extracts matching patterns]  
.b[`str_remove()`]  .f3[removes matched patterns]]
---
#Extract substrings

```{r}
team_record %>%
  mutate(result_comment = str_extract(
    string = result, pattern = "\\(.+\\)"))
```

--
*Can we strip the brackets with a regular expression?

---
## Extract substrings
.f2[`str_remove_all`]
```{r}
team_record %>%
  mutate(result_comment = str_extract(
    string = result, pattern = "\\(.+\\)")) %>% 
  mutate(result_comment=str_remove_all(result_comment,"[()]"))
```

---
# Remove substrings

```{r}
team_record %>%
  mutate(result=str_remove(
    string= result,pattern = " \\(.*\\)"))
```
---
class: my-turn

.f2[
1. Download CRAN package descriptions  
2. Select Package name, author, description, and all variables that contain 'License'  
3. Filter rows for packages with names that:  
 - start with _gg_ (case insensitivty)
 - contain _Bayes_
 - contain _glm_ but not _glmm_]

---
class: inverse
.f2[1. Download CRAN package descriptions  
2. Select Package name, author, description, and all variables that end in 'ports'  
3. Filter rows for packages with names that:  
 - end in _plot_
 - contain _Bayes_
 - contain digits  
 - are all UPPER CASE]
